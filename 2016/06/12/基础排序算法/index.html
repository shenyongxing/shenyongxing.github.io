<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>基础排序算法 | Where there is a will, there is a way!</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.3.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.3.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基础排序算法</h1><a id="logo" href="/.">Where there is a will, there is a way!</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">基础排序算法</h1><div class="post-meta">Jun 12, 2016<span> | </span><span class="category"><a href="/categories/C/">C</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>冒泡（升序）排序思想：冒泡排序即不断比较相邻的2个元素，如果左边的元素大于右边，则交换这2个元素，实现排序。那么第一轮冒泡结束后，最大的元素将在最右边。然后不断循环这个过程，直到排序完成。</p>
<p>注意：每一轮冒泡后，都将该轮循环中的最大数移动到了最右边，故每轮冒泡的循环次数应该减小一次。<br>代码如下：<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *	bubble sort算法学习</span><br><span class="line"> *	date:2016年6月10日</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bubbleSortAsc(int a[], int n);</span><br><span class="line">void printArray(int a[], int n);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int a[8] = &#123;5, 9, 7, 6, 13, 8, 1, 4&#125;;</span><br><span class="line">	printf(&quot;冒泡排序升序排列:\n&quot;);</span><br><span class="line">	bubbleSortAsc(a, 8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 冒泡排序,升序排列</span><br><span class="line">void bubbleSortAsc(int a[], int n) &#123;</span><br><span class="line">	int length = n;</span><br><span class="line">	int swapTmp = 0;</span><br><span class="line">	int circleCount = 0;	// 循环次数</span><br><span class="line">	// 注意循环时lenght要减1, 因为n个元素只需要n - 1次循环</span><br><span class="line">	for (int i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">		// 由于是升序排列,所以将大数向右边移动,故每轮排序最右边一定是最大的</span><br><span class="line">		// 故第二层循环不用考虑最右边元素</span><br><span class="line">		// 此处length - 1是因为a[j + 1]的原因，和外层循环的-1意义不一样</span><br><span class="line">		for (int j = 0; j &lt; length - 1 - i; j++) &#123;</span><br><span class="line">			if (a[j] &gt; a[j + 1]) &#123;</span><br><span class="line">				swapTmp = a[j + 1];</span><br><span class="line">				a[j + 1] = a[j];</span><br><span class="line">				a[j] = swapTmp;</span><br><span class="line">			&#125;</span><br><span class="line">			circleCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;第%d次排序结果:&quot;, i + 1);</span><br><span class="line">		printArray(a, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;总循环%d次\n&quot;, circleCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印数组</span><br><span class="line">void printArray(int a[], int n) &#123;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		printf(&quot;%2d&quot;, a[i]);</span><br><span class="line">		if (i == n - 1) &#123;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;, &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>选择（升序）排序思想：不断比较待排序中的元素与指定元素的大小，如果找到比指定元素小的，则记录元素索引值（此时不交换），直到找到最小的元素，则交换这两个元素。然后不断的循环这个过程，直到排序完成。</p>
<p>例如，第一次循环将第1个元素认为最小，依次与后面的元素进行比较，如果发现比第1个元素小的，则记录该索引，利用该索引的值和后面的元素比较，如果找到更小的则更新最小值的索引，继续向后比较，直到找到最小元素及其索引，则替换。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 选择排序</span><br><span class="line">void selectionSort(int array[], int length) &#123;</span><br><span class="line">	int index = 0;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	// n个元素只需要n - 1次循环</span><br><span class="line">	for (int i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">		index = i;</span><br><span class="line">		// 注意此处的j &lt; length, 因为要遍历到最后一个元素a[length - 1]</span><br><span class="line">		for (int j = i + 1; j &lt; length; j++) &#123;</span><br><span class="line">			if (array[index] &gt; array[j]) &#123;</span><br><span class="line">				// 记录比a[index]小的索引,一直找到最后一个比当前元素小的</span><br><span class="line">				// 注意赋值后a[index]会改变,所以可以找到最小的元素</span><br><span class="line">				index = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (index != i) &#123;</span><br><span class="line">			tmp = array[index];</span><br><span class="line">			array[index] = array[i];</span><br><span class="line">			array[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;第%d次排序结果:&quot;, i + 1);</span><br><span class="line">		printArray(array, length);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>插入（升序）排序思想：将第一个元素作为已排好序的数组，然后取出第2个，从右向左（从后往前）依次和数组的元素比较，找到合适的位置，然后插入。然后在取出第3个元素，找到合适位置，插入，不断循环这个过程，直到排序完成。</p>
<p>百度知道上有个网友回答比较形象，即类似打扑克时排序。每次拿牌后从右到左依次次比较，直到找到相应位置插入。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序</span><br><span class="line">void insertSort(int array[], int length) &#123;</span><br><span class="line">	for (int i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">		int key = array[i + 1];</span><br><span class="line">		int j = i;	// 记录已排序好的数组最后一个元素索引</span><br><span class="line">		</span><br><span class="line">		// 然后【从后向前】循环，直到找到合适的位置即比前一个元素大，比后一个元素小</span><br><span class="line">		// 每循环一次，数组元素向后移动一位</span><br><span class="line">		// 已排序好的最后一个元素会被覆盖，但是不用担心，最后一个元素的值等于key的值</span><br><span class="line">		// 最后通过key赋值，可以还原</span><br><span class="line">		while (j &gt;= 0 &amp;&amp; key &lt; array[j]) &#123;</span><br><span class="line">			array[j + 1] = array[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		array[j + 1] = key;</span><br><span class="line">		printf(&quot;第%d次排序结果:&quot;, i + 1);</span><br><span class="line">		printArray(array, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h2><p>快速排序（升序）排序思想：将数组第一个元素作为一个关键元素，1.从数组最右边开始遍历，找到第一个比关键元素小的元素，将此元素赋值给第一个元素，并记录此时的下标索引【j】。2.从数组最左边开始找到第一个比关键元素大的元素，将此元素赋值给索引【j】处的元素，同时记录此时的下标索引【i】。不断重复1和2，直到索引【i】大于等于【j】，那么说明比关键元素小的都在左边，比关键元素大的都在右边。最后在采取递归方法排序左右两边的数组，即可实现排序。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">void quickSort(int *array, int left, int right) &#123;</span><br><span class="line">	if (left &gt; right) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int i = left;</span><br><span class="line">	int j = right;</span><br><span class="line">	int key = array[i];</span><br><span class="line">	while (i &lt; j) &#123;</span><br><span class="line">		while(i &lt; j &amp;&amp; key &lt;= array[j]) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		array[i] = array[j];</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		while(i &lt; j &amp;&amp; array[i] &lt;= key) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		array[j] = array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	// 在这种不断交叉赋值的时候不用担心原来的值丢失的情况，因为第一次赋值array[0]前已通过key保存了值</span><br><span class="line">	// 将关键元素赋值</span><br><span class="line">	array[i] = key;</span><br><span class="line">	quickSort(array, left, i - 1);</span><br><span class="line">	quickSort(array, i + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/算法/">算法</a><a href="/tags/排序/">排序</a></div><div class="post-nav"><a href="/2016/06/14/Android数据库升级总结/" class="pre">Android数据库升级总结</a><a href="/2016/06/12/ImageView的src与background属性的区别/" class="next">ImageView的src与background属性的区别</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Excel/">Excel</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/数据库升级/" style="font-size: 15px;">数据库升级</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/Android多语言/" style="font-size: 15px;">Android多语言</a> <a href="/tags/打包/" style="font-size: 15px;">打包</a> <a href="/tags/ImageView/" style="font-size: 15px;">ImageView</a> <a href="/tags/ScaleType/" style="font-size: 15px;">ScaleType</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/18/Android手动打包/">Android手动打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/14/Android数据库升级总结/">Android数据库升级总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/基础排序算法/">基础排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/ImageView的src与background属性的区别/">ImageView的src与background属性的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/16/Excel常用文本操作/">Excel常用文本操作</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.3.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:null" target="_blank" class="fa fa-email"> </a><a href="null" target="_blank" class="fa fa-weibo"></a><a href="null" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">夏天</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=1.3.0"></script></body></html>